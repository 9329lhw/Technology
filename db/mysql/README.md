## mysql
### 1.mysql基础整理
#### 1.1 MySQL物理文件类型
##### 1.1.1 日志文件
    1. 错误日志(Error Log)
    2. 二进制日志(Binary Log) 
    3. 事务日志(InnoDB redo Log & undo Log)
    4. 慢查询日志(Slow Query Log) 
    5. 查询日志(Query Log)
##### 1.1.2 数据库文件
    1. '.frm'文件 
        无论是那种存储引擎，创建表之后就一定会生成一个以表明命名
        的'.frm'文件。frm文件主要存放与表相关的数据信息，主要包括
        表结构的定义信息。当数据库崩 溃时，用户可以通过frm文件来
        恢复数据表结构。
    2. '.MYD'文件 
        “.MYD”文件是MyISAM存储引擎专用，存放MyISAM表的数据。每一
        个MyISAM表都会有一个“.MYD”文件与之对应，同样存放于所属数
        据库的文件夹下， 和“.frm”文件在一起。
    3. '.MYI'文件 
        “.MYI”文件也是专属于MyISAM存储引擎的，主要存放MyISAM表的
        索引相关信息。对于MyISAM存储来说，可以被cache 的内容主要就
        是来源于“.MYI”文件中。 每一个MyISAM表对应一个“.MYI”文件，
        存放于位置和“.frm”以及“.MYD”一样。
    4. '.ibd'文件和'.ibdata'文件
        这两种文件都是存放Innodb数据的文件，之所以有两种文件来存放
        Innodb的数据（包括索引），是因为Innodb的数据存储方式能够通
        过配置来决定是使用共享 表空间存放存储数据，还是独享表空间存
        放存储数据。独享表空间存储方式使用“.ibd”文件来存放数据，且
        每个表一个“.ibd”文件，文件存放在和MyISAM数据相 同的位置。
        如果选用共享存储表空间来存放数据，则会使用ibdata文件来存放，
        所有表共同使用一个（或者多个，可自行配置）ibdata文件。
##### 1.1.3 共享表空间与独占表空间区别
    共享表空间: 某一个数据库的所有的表数据，索引文件全部放在一个文件中。
     独占表空间: 每一个表都将会生成以独立的文件方式来进行存储，每一个表
     都有一个.frm表描述文件，还有一个.ibd文件。其中这个文件包括了单独一
     个表的数据 内容以及索引内容。
##### 1.1.3 其他配置文件
    1. 系统配置文件（my.ini或者my.cnf） 
    2. pid,err文件 
    3. socket文件
    
#### 1.2 MySQL影响性能的因素
    1. 执行时间：一段代码从开始运行到运行结束所使用的时间。 
    2. CPU时间：(算法)函数或者线程占用CPU的时间。 
    3. 内存分配：程序在运行时占用的内存空间。 
    4. 磁盘吞吐量：描述I/O的使用情况。 
    5. 网络吞吐量：描述网络的使用情况。 
    6. 响应时间：系统对某用户行为或者动作做出响应的时间。
    响应时间越短，性能好。
#### 1.3 MySQL命令
    show status 查看会话状态
        -- 查看当前会话情况 show status like 'Com_%';
        -- 查看全局会话情况 show global status like 'Com_%'; 
        -- 查看针对innodb存储引擎状态的统计 show global status like 'Innodb_%'; 
        -- 查看视图连接MySQL服务器次数 show global status like 'connections'; 
        -- 查看服务器工作时间 show global status like 'uptime'; 
        -- 查看锁使用情况 show global status like 'innodb_row_lock%';
    show processlist 显示了有哪些线程在运行
    show variables 查看mysql系统变量
#### 1.4 MySQL三大范式
#### 1.5 MySQL数据类型   

### 2.mysql底层
#### 2.1 SQL执行流程
### 2.mysql事务隔离级别
![lock](asset/lock.png)
#### 1.Read Uncommitted(读取未提交内容)
    (1)所有事务都可以看到其他未提交事务的执行结果 
    (2)本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少 
    (3)该级别引发的问题是——脏读(Dirty Read)：读取到了未提交的数据
#### 2.Read Committed(读取提交内容)
    (1)这是大多数数据库系统的默认隔离级别（但不是MySQL默认的） 
    (2)它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变 
    (3)这种隔离级别出现的问题是——不可重复读(Nonrepeatable Read)：不可重复读意味着
    我们在同一个事务中执行完全相同的select语句时可能看到不一样的结果。 |——>导致这种情况的原因可能有：
    (1)有一个交叉的事务有新的commit，导致了数据的改变;
    (2)一个数据库被多个实例操作时,同一事务的其他实例在该实例处理其间可能会有新的commit
#### 3.Repeatable Read(可重读)
    (1)这是MySQL的默认事务隔离级别 
    (2)它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行 
    (3)此级别可能出现的问题——幻读(Phantom Read)：当用户读取某一范围的数据行时，另一个事务又
    在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行 
    (4)InnoDB和Falcon存储引擎通过多版本并发控制(MVCC，Multiversion Concurrency Control)
    机制解决了幻读
#### 4.Serializable(可串行化)
    (1)这是最高的隔离级别 
    (2)它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之,它是在每个读的
        数据行上加上共享锁。 
    (3)在这个级别，可能导致大量的超时现象和锁竞争
    
### mysql锁
#### 1.行锁
#### 2.表锁
#### 3.间隙锁（gap）
    说白了gap就是索引树中插入新记录的空隙。相应的gap lock就是加在gap上的锁，
    还有一个next-key锁，是记录+记前面的gap的组合的锁。
##### 3.1 订单如何防止间隙锁：
    1 尽量采用乐观锁，乐观锁是在php等代码层面的锁，就不会锁住数据库资源
    2 事务中update，where后面的字段尽量带上索引，不然间隙锁的范围很大
    3 尽量不要出现长事务，否则事务中更新订单时间隙锁会被锁很久，另一事务插入订单就会执行很久
    4 update订单表，begin和commit之间的时间不要太长，之间不要写一些慢代码，比如请求第三方接口
    5 分表能防止不分表情况下整张表被锁住。分表后是锁住众多表中的其中一张
#### 4.什么是死锁
    所谓死锁，是指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，
    若无外力作用，它们都将无法再向前推进。
#### 5.死锁怎么解决
    1. 等待，直到超时（innodb_lock_wait_timeout=10s）。
    2. 发起死锁检测，主动回滚一条事务，让其他事务继续执行（innodb_deadlock_detect=on）。
#### 3.如何避免发生死锁
    1. 操作完之后立即提交事务，特别是在交互式命令行中。比如中途不要去请求第三方接口或者
    执行一些慢逻辑，能不放到事务里面的php代码， 就别放到事务里面
    2. 资源一次性分配
        一次性锁协议，事务开始时，即一次性申请所有的锁，之后不会再申请任何锁，如果其中
        某个锁不可用，则整个申请就不成功，事务就不会执行，在事务尾端，一次性释放所有的
        锁。一次性锁协议不会产生死锁的问题，但事务的并发度不高。
    3.尽量采用乐观锁，因为悲观锁都是要求mysql锁资源，而乐观锁不是
    4. 采用超时设置，时间越短，锁等待时间越短。到点就会自动超时，不会继续等待锁释放
    5. 保证没有长事务，长事务尽量拆分成短事务，以为2个短事务很难重合到一起。就是说，
    如果一个事务瞬间执行完毕了，就很好，如果一直没执行完毕， 就很可能另外一个事务
    冲进来二者重合。就加大死锁几率
    6. 修改多个表或者多个行的时候，将修改的顺序保持一致。死锁是因为锁定
    资源的顺序刚好相反。如果顺序是一样的，就不会产生死锁。
    7. 创建索引，可以使创建的锁关联到的数据更少。如果where后面的字段没有索引，
    哪怕只操作一行数据， 也会锁整张表， 因为锁是基于索引的。    
	https://www.cnblogs.com/hhthtt/p/10707541.html

### mysql索引
#### 回表
#### 如何创建联合索引
    select count(distinct yearbonus)/ count(*) as year_select, 
    count(distinct monthsalary)/ count(*) as mon_select, 
    count(distinct TIMESTAMPDIFF(YEAR, birthdate, CURDATE())) / count(*) as bir_select, 
    count(*) as counts 
    from customers1;
    哪个值最高就放最前
#### 从数据结构角度
    1、B+树索引(O(log(n)))：关于B+树索引，可以参考 MySQL索引背后的数据结构及算法原理
    2、hash索引：
    a 仅仅能满足"=","IN"和"<=>"查询，不能使用范围查询
    b 其检索效率非常高，索引的检索可以一次定位，不像B-Tree 索引需要从根节点到枝节点，
    最后才能访问到页节点这样多次的IO访问，所以 Hash 索引的查询效率要远高于 B-Tree 索引
    c 只有Memory存储引擎显示支持hash索引
    3、FULLTEXT索引（现在MyISAM和InnoDB引擎都支持了）
    4、R-Tree索引（用于对GIS数据类型创建SPATIAL索引）
#### 从物理存储角度
    1、聚集索引（clustered index）
    2、非聚集索引（non-clustered index）
    聚集索引和非聚集索引的区别如下：
    　　1) 聚集索引和非聚集索引的根本区别是表记录的排列顺序和与索引的排列顺序是否一致，
    聚集索引表记录的排列顺序与索引的排列顺序一致，优点是查询速度快，因为一旦
    具有第一个索引值的纪录被找到，具有连续索引值的记录也一定物理的紧跟其后。
    　　2) 聚集索引的缺点是对表进行修改速度较慢，这是为了保持表中的记录的物理顺序与索
    引的顺序一致，而把记录插入到数据页的相应位置，必须在数据页中进行数据重排，
    降低了执行速度。非聚集索引指定了表中记录的逻辑顺序，但记录的物理顺序和索引的顺序不
    一致，聚集索引和非聚集索引都采用了B+树的结构，但非聚集索引的叶子层并不与实际的
    总结：
    1.聚集索引查找速度比非聚集索引快,聚集索引的排序是顺序的
    2.聚集索引修改比较慢
#### 从逻辑角度
    1、主键索引：主键索引是一种特殊的唯一索引，不允许有空值
    2、普通索引或者单列索引
    3、多列索引（复合索引）：复合索引指多个字段上创建的索引，只有在查询条件中使用
    了创建索引时的第一个字段，索引才会被使用。使用复合索引时遵循最左前缀集合
    4、唯一索引或者非唯一索引
    5、空间索引：空间索引是对空间数据类型的字段建立的索引，MYSQL中的空间数据类型有4种，
    分别是GEOMETRY、POINT、LINESTRING、POLYGON。MYSQL使用SPATIAL关键字进行扩展，使得
    能够用于创建正规索引类型的语法创建空间索引。创建空间索引的列，必须将其声明为NOT 
    NULL，空间索引只能在存储引擎为MYISAM的表中创建
    CREATE TABLE table_name[col_name data type]
    [unique|fulltext|spatial][index|key][index_name](col_name[length])[asc|desc]
    1、unique|fulltext|spatial为可选参数，分别表示唯一索引、全文索引和空间索引；
    2、index和key为同义词，两者作用相同，用来指定创建索引
    3、col_name为需要创建索引的字段列，该列必须从数据表中该定义的多个列中选择；
    4、index_name指定索引的名称，为可选参数，如果不指定，MYSQL默认col_name为索引值；
    5、length为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度；
    6、asc或desc指定升序或降序的索引值存储
### 主从延时
    我们可以使用percona-toolkit工具做校验，而该工具包含 
    1. pt-table-checksum 负责检测MySQL主从数据一致性 
    2. pt-table-sync负责挡住从数据不一致时修复数据，让他们保存数据的一致性 
    3. pt-heartbeat 负责监控MySQL主从同步延迟
### 分库分表
    垂直分库
    水平分库
    垂直分表
    水品分表
    异构索引表
    分库分表使用场景
    1.订单分库分表
### 分布式事务
	https://www.cnblogs.com/jajian/p/10014145.html
	xa事务
	2pc(两阶段提交)：第一次提交时准备操作，第二次提交时真正的提交-------------->产生的问题：数据不一致
    	3pc(三阶段提交)：在2pc的基础上多了一次消息通知的阶段住要 第一次提交完了通知第二次进行提交--------->mysql官方暂时未实现
    	tcc(TCC两阶段补偿型)：在2pc的基础上使用接口来处理事务的回滚操作
	mq(最终一致性，幂等性)：使用rabbit ack高级特性
## 分布式事务行业主要解决方案介绍
#### 两阶段提交（2PC）（two-phase commit protocol）
    第一阶段：请求/表决阶段
    第二阶段：提交/执行阶段（正常流程）
    第二阶段：提交/执行阶段（异常流程）
    遇到的一些问题：
       1.性能问题
       2.协调者单点故障问题
       3.丢失消息导致的数据不一致问题
#### 三阶段提交（3PC）
    三阶段提交又称3PC，其在两阶段提交的基础上增加了CanCommit阶段，
    并引入了超时机制。一旦事务参与者迟迟没有收到协调者的Commit请求，
    就会自动进行本地commit，这样相对有效地解决了协调者单点故障的问题。
    3PC解决了2PC1,2问题但是任然没有完全解决数据不一致的问题
#### 补偿事务（TCC）
    Try阶段：主要是对业务系统做检测及资源预留。
    Confirm阶段：确认执行业务操作。 通过调用确认接口
    Cancel阶段：取消执行业务操作。 通过调用取消接口
    不足之处则在于对应用的侵入性非常强，业务逻辑的每个分支都需要实现try、confirm、cancel三个操作。此外，
    其实现难度也比较大，需要按照网络状态、系统故障等不同的失败原因实现不同的回滚策略
#### MQ最终一致性事务
    1 消息百分百投递成功
    结合comfirm机制
    2 消息百分百消费成功
    结合ack机制
    并且要解决幂等性问题
### 高可用
#### MHA
##### 1.MHA原理
    1. 从宕机崩溃的master保存二进制日志事件（binlog events） 
    2. 识别含有最新更新的slave 
    3. 应用差异的中继日志（relay log）到其他的slave；
    4. 应用从master保存的二进制日志事件（binlog events）； 
    5. 提升一个slave为新的master； 
    6. 使其他的slave连接新的master进行复制；